# 정렬 알고리즘

# Q 1 . 정렬 알고리즘의 종류에는 어떤게 있나요?
* 정렬을 수행하는 데에 추가 메모리가 O(logN) 이하로 사용되는 In-place 알고리즘과, 동일 값의 정렬 전후의 순서가 유지되는 Stable 알고리즘이 존재합니다.
# Q 2 . 합병 정렬이란 무엇인가요?
* 합병 정렬은 정렬되지 않은 리스트를 두 부분 리스트로 나눠가며 더이상 나눌 수 없는 경우 정렬을 진행하며 다시 합병 되는 방식의 정렬입니다. 시간 복잡도가 전체 O(nlogn) 이란 점에서 효율적인 정렬로 stable 한 정렬입니다.

# Q 3 . 퀵 정렬이란 무엇인가요?
* 퀵 정렬은 리스트에서 하나의 pivot 을 선택하고 왼쪽에는 작은 값, 오른쪽에는 큰 값들을 넣어가며 정렬하고 다시 pivot 값을 선택해서 진행해나가는 정렬입니다. 다른 정렬과는 다르게 정렬되있는 경우에 최악의 시간 복잡도를 가지고 이외의 경우에는 O(nlongn) 이라는 시간 복잡도를 가지게 됩니다.

# Dynamic Programing

## Q 1. Dynamic Programing 이란 무엇인가요?
* 복잡한 문제를 보다 단순한 부분 문제로 재귀적으로 나누어 해결하는 방법입니다. 부분 문제들의 최적해가 전체의 최적해를 이루는 Optimal Substructure 과 동일한 부분 문제가 여러번 발생하는 Overlapping Sub-Problems 조건이 만족되야 합니다. Memoization 기법을 통해 중요한 연산을 미리 캐싱해두고 참조하며 연산을 줄일 수 있습니다.


# 해시

## Q 1 . 해시란 무엇인가요 ?
* 빠르게 계산할 수 있는 해시 함수를 이용해 해시값으로 변환하는 기법입니다. 일반적으로 입력의 범위보다 해시값의 범위는 감소합니다. 해시 함수는 동일 입력에 대해서 동일 출력을 보장합니다. 해시 함수의 선택에 따라 성능의 차이가 발생하기 때문에 해시 함수를 잘 선택하는 것이 중요합니다.

## Q 2 . 해시 테이블은 무엇인가요 ?
* 해시 테이블은 Key 와 Value 의 쌍을 저장하는 자료구조로입니다. key 의 해시값을 index 로 해 Hash Table 에 Key 와 Value 를 저장하는 자료구조 입니다. Key 는 중복이 불가능 하지만, Value 는 중복이 허용됩니다. key 를 index 로 접근하기 때문에 O(1) 이라는 시간 복잡도를 가질 수 있는 효율적인 자료구조입니다.

## Q 3 . 해시 충돌이란 무엇인가요 ? 
* 서로 다른 입력 값에 대해서 해시 함수가 동일 출력을 내는 경우를 이야기합니다. 만약 모든 해시값에서 해시 충돌이 발생한다면, 탐색 성능이 O(N) 으로 하락합니다.

## Q 4 . 해시 충돌을 회피하는 기법에 대해서 얘기해주세요.
* 개방 주소법과 체이닝 기법이 대표적으로 사용되는 2가지 기법입니다. 먼저 개방 주소법의 경우에는 Table 의 다른 index 를 선택해 해시 충돌을 해결합니다. 더이상 충돌이 발생하지 않을때까지 반복해서 사용합니다. 개방 주소법에는 선형 탐사, 이차 탐사, 이중 해싱이라는 방법이 존재합니다. 선형 탐사의 경우 정해진 값만큼 index 를 이동하는 방법으로 보통 1을 사용합니다. 이차 탐사의 경우 index 를 제곱하는 값으로 이동하고 이중 해싱의 경우 별도의 해시 함수를 이용해서 이동 간격을 결정합니다.
* 체이닝 기법의 경우에는 해시 충돌이 발생할 경우에 LinkedList 에 Node 를 추가하는 방법으로 해결합니다. Table 에 값을 저장하는 대신 LinkedList 를 저장해서 해결합니다.

# 탐색 알고리즘

## Q 1 . 탐색 알고리즘에 대해서 얘기해주세요.
* 자료구조에서 원하는 조건에 맞는 자료를 찾는 것을 탐색 알고리즘이라고 합니다. 자료의 정렬 여부에 따라 크게 선형 탐색, 이분 탐색으로 나뉩니다. 선형 탐색의 경우는 순차 탐색이라고 부르며, 가장 단순한 탐색 알고리즘입니다. 순서대로 하나씩 비교해 나가기 때문에 O(N) 의 시간 복잡도가 걸립니다. 이분 탐색의 경우 절렬된 자료의 탐색에 가장 많이 사용됩니다. 주로 첫 인덱스와 끝 인덱스를 더하고 2로 나눈 중간값을 사용해 비교값보다 크면 왼쪽으로 작으면 오른쪽으로 이동해 반복해 O(longN) 으로 탐색이 가능합니다.

# Tree 알고리즘

## Q 1 . Heap 에 대해서 설명해주세요.
* heap 은 항상 부모노드가 자식 노드보다 크거나 같은 자료구조입니다. 우선순위 큐의 내부는 heap 으로 이루어져 있으며 최대/최소 힙으로 구분되어 있습니다. heap 은 자료 삽입시에 배열의 맨 뒤에 자료를 삽입하고 부모 노드와의 비교를 통해 swap 연산 여부를 결정하며 최대 logN 번 반복합니다. 자료를 삭제 할 경우 루트 노드를 삭제하고 맨 마지막의 원소를 루트노드로 대치합니다. 삽입과 반대로 자식 노드와의 비교를 통해 swap 연산을 마찬가지로 최대 logN 번 진행해 내부를 정렬합니다.


## Q 2 . Trie 에 대해서 설명해주세요.
* Trie 는 단어 검색에 최적화 되있는 Tree 구조의 자료구조입니다. 일반적인 문자열의 경우 문자를 찾기 위해서는 문자의 길이와 단어 수 만큼의 시간 복잡도가 발생하지만, Trie 의 경우 탐색은 문자의 길이 만큼만 발생하게 됩니다. 문자열을 삽입할 경우 먼저 자식 노드에 문자가 있는지 확인하고 없다면 노드를 만들어 줍니다. 이 과정을 반복해 마지막 문자까지 전부 삽입한 경우 리프 노드에 문자열의 마지막이라는 표시로 특수 문자를 삽입합니다. 이 특수문자를 통해 우리는 중복된 문자가 삽입 됬는지 안 됬는지를 알 수 있습니다. 예를 들어 car , card 가 들어왔다고 할 때 특수 문자 없이는 car 가 들어왔는지 구별하기 어려울 것 입니다. 
