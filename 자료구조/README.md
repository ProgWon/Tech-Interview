# 자료 구조

## Q 1 . 추상 자료형과 자료 구조의 차이는 뭔가요?
* 추상 자료형과 자료구조는 굉장히 유사하지만 가장 큰 차이점은 구현 여부라고 할 수 있습니다. 자료구조의 경우에는 실제로 구현되어 사용 할 수 있지만 추상 자료형의 경우는 실제로 구현되어 있지 않은 수학적 모델로 개발자 입장의 구현 측면에서의 고려가 들어있지 않습니다.

## Q 2 추상 자료형과 자료구조의 예를 들어 설명 해 줄수있을까요?
* 예를 들면 스택의 형태는 LIFO 값들의 모임이고 push 나 size 등의 연산 정의가 가능합니다. 하지만 스택이 내부적으로 배열로 구성되어 있는지, 연결리스트로 구현되어있는지, size 연산 수행시에 원소의 개수를 일일이 세는지에 대한 세부 사항들은 추상 자료형에서는 다루지 않습니다. 만약 이런 것들을 다루기 시작한다면 자료구조의 영역으로 넘어가게 됩니다.

# Array, LinkedList

## Q 1 . Array 와 LinkedList 의 차이가 무엇인가요?
* Array 는 Random Access 를 지원합니다. 따라서 특정 요소 접근시에 O(1) 의 시간 복잡도를 가지게 됩니다. 반면에 LinkedList 는 Sequential Access 를 지원합니다. 어떤 요소에 접근하기 위해서는 순차적으로 검색하며 찾아야 됩니다. 따라서 특정 요소 접근시에는 O(N) 의 시간복잡도를 가지게 됩니다.
* Array 는 메모리 선언시에 미리 공간을 지정해줘야 합니다. 이 때문에 정해진 크기 만큼만 사용이 가능한 반면에 LinkedList 의 경우 동적으로 메모리 할당이 됩니다.
* Array 저장된 위치에 메모리 주소 연속성이 보장됩니다. 반면 LinkedList 의 경우는 새로운 요소에 할당된 메모리 위치 주소가 이전 요소에 저장됩니다.

## Q 2 . LinekdList 의 종류에 대해서 알고 있는게 있다면 말해보세요.
* LinkedList 의 경우 단방향 연결리스트 뿐만 아니라 **원형 연결리스트** 와 **이중 연결 리스트** 또한 존재합니다.
* 이중 연결리스트의 경우 앞의 노드를 가르키는 포인터를 저장하는 공간을 만들어 이전 노드의 접근이 가능하도록 만든 구조입니다. 앞을 가르키는 prev 포인터를 이용해 노드의 수가 n인 이중 연결 리스트에서 n/2 보다 작은 순서의 노드는 head 에서 탐색하고 n/2 보다 크거나 같은 순서의 노드는 tail 에서 탐색하도록 구현하여 일반적인 연결리스트에 비해 반으로 줄이는 것이 가능합니다.
* 원형 연결리스트는 마지막 노드를 참조하는 last 가 단순 연결리스트의 head 역할을 합니다. 여러 사람이 차례대로 돌아가면서 플레이하는 게임을 구현하기에 적합하고 많은 사용자들이 동시에 사용하는 컴퓨터에서 CPU 시간을 분할하여 작업들에 용이합니다.

## Q 3 . ArrayList 와  LinkedList 의 차이는 뭔가요?
* ArrayList 는 말 그대로 Array 를 통해 만들어졌습니다. 따라서 정해진 길이 부터 시작하지만, 내부 구현을 통해 일반적으로 크기가 꽉 찼을 경우에 사이즈를 2배로 만들고 복사해서 넣어주는 과정을 진행하게 됩니다.
* LinkedList 는 값과 다음 요소를 가르키는 연결로 구성되어 있어 사이즈를 미리 지정해주는 수고를 덜 수 있습니다.
* 두 개의 차이는 ArrayList 의 경우 index 를 통한 Random Access 가 가능해 access 의 경우 O(1) 의 시간 복잡도가 드는 반면, LinkedList 의 경우 노드를 head 부터 하나씩 찾아 나가야 하기 때문에 O(N) 이 걸린다는 단점이 있습니다. 하지만 LinkedList 는 ArrayList 처럼 공간이 꽉 찬 경우 복사를 해주는 연산이 필요없어 내부적으로 구현상의 시간복잡도를 줄일 수 있다는 장점이 있습니다.

# Stack, Queue

## Q 1 . Stack 과 Queue 의 차이점을 설명해주세요.
* Stack 은 쌓아 올리는 자료 구조입니다. 정해진 방향으로 데이터를 쌓아 올릴 수 있고, top 을 통해서 push, pop 삽입 삭제가 일어나는 후입 선출 구조입니다.
* **Queue** 의 경우 선입 선출의 특성을 가지는 추상 자료형입니다. 입력된 데이터가 순서대로 처리되어야 할 때 사용합니다. 
## Q 2 . Queue 는 어떻게 구현하는지 알려주세요. 그리고 각각의 장단점에 대해서도 말해주세요.
* 먼저 선형 큐가 존재합니다. 맨 앞을 나타내는 front, 끝을 나타내는 rear 로 이루어져 있습니다. 데이터가 삽입되면 rear 는 + 1 되어 뒤로 이동하고 데이터를 빼내는 경우에는 맨 앞의 요소를 빼고 front 가 +1 이 됩니다. 이렇게 삭제 및 삽입을 반복하게 되면 rear 가 맨 마지막 인덱스를 가르키게 되고, Queue 의 앞은 비어 있지만 이를 꽉 찼다고 인식을 하게 됩니다. 실제로 데이터를 삭제 할 때마다 앞으로 한 칸씩 이동하지 않았고 인덱스 단위로 큐의 연산이 진행됬기 때문입니다. 
* 이러한 단점을 해결하기 위해 생겨난 아이디어가 원형 큐 입니다. 1차원 배열을 사용하지만 처음과 긑을 원형처럼 이어졌다고 가정합니다. 이는 배열의 크기 만큼을 % 연산을 해 구현합니다. 만약 rear + 1이 front 라면 꽉 차 있다고 판단합니다.
* 연결리스트 큐의 경우는 연결 리스트를 통해 큐를 구성하고 양방향 연결리스트를 사용하기 때문에 물리적인 메모리를 전부 사용하기 전까지는 Overflow 가 발생하지 않습니다.
## Q 3 . 배열 한 개로 여러개의 Stack 을 구현한다고 생각해볼게요. 어떻게 구현하실지 얘기해주세요.
* 배열의 index 를 구현할 Stack 의 크기 만큼 나눠서 구현할 것 같습니다. 정적으로 할당 되어 있는 공간을 동적으로 사용하려면 스택에 넣을 공간이 부족할 때의 스택의 공간을 늘려주고, 그 자리에 있던 원소들을 밀어주면 될 것 같습니다. 

## Q 4. Priority Queue 란 무엇인가요?
* Priority Queue 는우선 순위 큐로 우선 순위가 높은 데이터를 먼저 꺼내기 위해 고안된 자료 구조입니다. 내부는 Min Heap/Max Heap 으로 구성되어 있습니다. heap 은 완전 이진 트리를 기반으로 하기 때문에 O(logN)의 연산을 통해 최대/최소 값을 반환 할 수 있는 이점이 있습니다.
# Tree

## Q 1 . Tree 가 무엇인지 간략하게 설명해주세요.
* 트리는 그래프의 일종으로 여러 노드가 한 노드를 가르킬 수 없는 구조입니다. cycle 이 존재하지 않아, 두 노드를 잇는 path 가 한 개 밖에 없는 구조입니다.

## Q 2 . Tree 와 Binary Tree 의 차이점은 무엇인가요?
* 일반적인 Tree 는 여러개의 자식 노드들로 구성이 가능하지만 Binary Tree 는 자식 노드가 최대 2 개인 노드들로 구성되어 있는 트리입니다. 

## Q 3 . Binary Tree 의 종류에는 어떤 것들이 있나요?
* 정 이진 트리, 완전 이진 트리, 균형 이진 트리가 있습니다.
* 정 이진 트리의 경우 루트 노드를 제외한 모든 노드들은 2개의 자식 노드를 가지거나 자식 노드가 하나도 없어야 하는 조건을 만족한 트리입니다.
* 완전 이진 트리의 경우 마지막 레벨을 제외한 나머지 레벨에서는 노드들이 꽉 차 있어야 합니다. 또한 마지막 레벨은 왼쪽부터 노드가 채워져 있어야 합니다.
* 균형 이진 트리는 Skewed Tree 나 Balanced Binary Tree 를 얘기 합니다. 한쪽으로 치우쳐져 있거나 균형 잡힌 이진 트리를 얘기합니다.

## Q 4 . Binary Tree 와 Binary Search Tree 의 차이점이 무엇인가요?
* BST 의 경우에는 노드의 값에 '순서' 나 '크고 작음' 이 존재합니다. 노드의 왼쪽 서브트리의 경우에는 그 노드의 값보다 작은 값을 가진 노드로 이루어져 있고 반대로 오른쪽 서브 트리는 그 노드의 값보다 큰 값을 가진 노드로 이루어져 있습니다.

## Q 5 . BST 의 시간 복잡도는 어떻게 되나요? 이상적인 경우와 Worst Case 에 대해서도 얘기해주세요.
* Worst Case 인 경우는 Skewed Tree 가 될 경우 입니다. 이때에는 정렬된 배열과 시간복잡도가 같아져 O(N) 의 시간복잡도를 가지게 됩니다.
* 이상적인 경우는 밸런스가 잘 맞는 경우로 한 쪽으로 치우쳐지지 않았을 때입니다. 이때 탐색, 삽입, 삭제의 경우 모두 O(logN) 의 시간복잡도를 가지게 됩니다.
