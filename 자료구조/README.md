# 자료 구조

## Q 1 . 추상 자료형과 자료 구조의 차이는 뭔가요?
* 추상 자료형과 자료구조는 굉장히 유사하지만 가장 큰 차이점은 구현 여부라고 할 수 있습니다. 자료구조의 경우에는 실제로 구현되어 사용 할 수 있지만 추상 자료형의 경우는 실제로 구현되어 있지 않은 수학적 모델로 개발자 입장의 구현 측면에서의 고려가 들어있지 않습니다.

## Q 2 . 추상 자료형과 자료구조의 예를 들어 설명 해 줄수있을까요?
* 예를 들면 스택의 형태는 LIFO 값들의 모임이고 push 나 size 등의 연산 정의가 가능합니다. 하지만 스택이 내부적으로 배열로 구성되어 있는지, 연결리스트로 구현되어있는지, size 연산 수행시에 원소의 개수를 일일이 세는지에 대한 세부 사항들은 추상 자료형에서는 다루지 않습니다. 만약 이런 것들을 다루기 시작한다면 자료구조의 영역으로 넘어가게 됩니다.

## Q 3 . 자료구조란 무엇인가요?
* 자료구조는 자료 값의 모임, 자료 간의 관계, 그리고 자료에 적용할 수 있는 연산들을 정의해 놓은 것을 이야기합니다. 자료구조를 사용하면 자료의 중복 최소화로 저장 장치를 효율적으로 사용하고 필요한 자료에 빠르게 접근이 가능하다는 장점이 있습니다.

# Array, LinkedList

## Q 1 . Array 와 LinkedList 의 차이가 무엇인가요?
* Array 는 Random Access 를 지원합니다. 따라서 특정 요소 접근시에 O(1) 의 시간 복잡도를 가지게 됩니다. 반면에 LinkedList 는 Sequential Access 를 지원합니다. 어떤 요소에 접근하기 위해서는 순차적으로 검색하며 찾아야 됩니다. 따라서 특정 요소 접근시에는 O(N) 의 시간복잡도를 가지게 됩니다.
* Array 는 메모리 선언시에 미리 공간을 지정해줘야 합니다. 이 때문에 정해진 크기 만큼만 사용이 가능한 반면에 LinkedList 의 경우 동적으로 메모리 할당이 됩니다.
* Array 저장된 위치에 메모리 주소 연속성이 보장됩니다. 반면 LinkedList 의 경우는 새로운 요소에 할당된 메모리 위치 주소가 이전 요소에 저장됩니다.

## Q 2 . LinekdList 의 종류에 대해서 알고 있는게 있다면 말해보세요.
* LinkedList 의 경우 단방향 연결리스트 뿐만 아니라 **원형 연결리스트** 와 **이중 연결 리스트** 또한 존재합니다.
* 이중 연결리스트의 경우 앞의 노드를 가르키는 포인터를 저장하는 공간을 만들어 이전 노드의 접근이 가능하도록 만든 구조입니다. 앞을 가르키는 prev 포인터를 이용해 노드의 수가 n인 이중 연결 리스트에서 n/2 보다 작은 순서의 노드는 head 에서 탐색하고 n/2 보다 크거나 같은 순서의 노드는 tail 에서 탐색하도록 구현하여 일반적인 연결리스트에 비해 반으로 줄이는 것이 가능합니다.
* 원형 연결리스트는 마지막 노드를 참조하는 last 가 단순 연결리스트의 head 역할을 합니다. 여러 사람이 차례대로 돌아가면서 플레이하는 게임을 구현하기에 적합하고 많은 사용자들이 동시에 사용하는 컴퓨터에서 CPU 시간을 분할하여 작업들에 용이합니다.

## Q 3 . ArrayList 와  LinkedList 의 차이는 뭔가요?
* ArrayList 는 말 그대로 Array 를 통해 만들어졌습니다. 따라서 정해진 길이 부터 시작하지만, 내부 구현을 통해 일반적으로 크기가 꽉 찼을 경우에 사이즈를 2배로 만들고 복사해서 넣어주는 과정을 진행하게 됩니다.
* LinkedList 는 값과 다음 요소를 가르키는 연결로 구성되어 있어 사이즈를 미리 지정해주는 수고를 덜 수 있습니다.
* 두 개의 차이는 ArrayList 의 경우 index 를 통한 Random Access 가 가능해 access 의 경우 O(1) 의 시간 복잡도가 드는 반면, LinkedList 의 경우 노드를 head 부터 하나씩 찾아 나가야 하기 때문에 O(N) 이 걸린다는 단점이 있습니다. 하지만 LinkedList 는 ArrayList 처럼 공간이 꽉 찬 경우 복사를 해주는 연산이 필요없어 내부적으로 구현상의 시간복잡도를 줄일 수 있다는 장점이 있습니다.

# Stack, Queue

## Q 1 . Stack 과 Queue 의 차이점을 설명해주세요.
* Stack 은 쌓아 올리는 자료 구조입니다. 정해진 방향으로 데이터를 쌓아 올릴 수 있고, top 을 통해서 push, pop 삽입 삭제가 일어나는 후입 선출 구조입니다.
* **Queue** 의 경우 선입 선출의 특성을 가지는 추상 자료형입니다. 입력된 데이터가 순서대로 처리되어야 할 때 사용합니다. 
## Q 2 . Queue 는 어떻게 구현하는지 알려주세요. 그리고 각각의 장단점에 대해서도 말해주세요.
* 먼저 선형 큐가 존재합니다. 맨 앞을 나타내는 front, 끝을 나타내는 rear 로 이루어져 있습니다. 데이터가 삽입되면 rear 는 + 1 되어 뒤로 이동하고 데이터를 빼내는 경우에는 맨 앞의 요소를 빼고 front 가 +1 이 됩니다. 이렇게 삭제 및 삽입을 반복하게 되면 rear 가 맨 마지막 인덱스를 가르키게 되고, Queue 의 앞은 비어 있지만 이를 꽉 찼다고 인식을 하게 됩니다. 실제로 데이터를 삭제 할 때마다 앞으로 한 칸씩 이동하지 않았고 인덱스 단위로 큐의 연산이 진행됬기 때문입니다. 
* 이러한 단점을 해결하기 위해 생겨난 아이디어가 원형 큐 입니다. 1차원 배열을 사용하지만 처음과 긑을 원형처럼 이어졌다고 가정합니다. 이는 배열의 크기 만큼을 % 연산을 해 구현합니다. 만약 rear + 1이 front 라면 꽉 차 있다고 판단합니다.
* 연결리스트 큐의 경우는 연결 리스트를 통해 큐를 구성하고 양방향 연결리스트를 사용하기 때문에 물리적인 메모리를 전부 사용하기 전까지는 Overflow 가 발생하지 않습니다.
## Q 3 . 배열 한 개로 여러개의 Stack 을 구현한다고 생각해볼게요. 어떻게 구현하실지 얘기해주세요.
* 배열의 index 를 구현할 Stack 의 크기 만큼 나눠서 구현할 것 같습니다. 정적으로 할당 되어 있는 공간을 동적으로 사용하려면 스택에 넣을 공간이 부족할 때의 스택의 공간을 늘려주고, 그 자리에 있던 원소들을 밀어주면 될 것 같습니다. 

## Q 4. Priority Queue 란 무엇인가요?
* Priority Queue 는우선 순위 큐로 우선 순위가 높은 데이터를 먼저 꺼내기 위해 고안된 자료 구조입니다. 내부는 Min Heap/Max Heap 으로 구성되어 있습니다. heap 은 완전 이진 트리를 기반으로 하기 때문에 O(logN)의 연산을 통해 최대/최소 값을 반환 할 수 있는 이점이 있습니다.
# Tree

## Q 1 . Tree 가 무엇인지 간략하게 설명해주세요.
* 트리는 그래프의 일종으로 여러 노드가 한 노드를 가르킬 수 없는 구조입니다. cycle 이 존재하지 않아, 두 노드를 잇는 path 가 한 개 밖에 없는 구조입니다.

## Q 2 . Tree 와 Binary Tree 의 차이점은 무엇인가요?
* 일반적인 Tree 는 여러개의 자식 노드들로 구성이 가능하지만 Binary Tree 는 자식 노드가 최대 2 개인 노드들로 구성되어 있는 트리입니다. 

## Q 3 . Binary Tree 의 종류에는 어떤 것들이 있나요?
* 정 이진 트리, 완전 이진 트리, 균형 이진 트리가 있습니다.
* 정 이진 트리의 경우 루트 노드를 제외한 모든 노드들은 2개의 자식 노드를 가지거나 자식 노드가 하나도 없어야 하는 조건을 만족한 트리입니다.
* 완전 이진 트리의 경우 마지막 레벨을 제외한 나머지 레벨에서는 노드들이 꽉 차 있어야 합니다. 또한 마지막 레벨은 왼쪽부터 노드가 채워져 있어야 합니다.
* 균형 이진 트리는 Skewed Tree 나 Balanced Binary Tree 를 얘기 합니다. 한쪽으로 치우쳐져 있거나 균형 잡힌 이진 트리를 얘기합니다.

## Q 4 . Binary Tree 와 Binary Search Tree 의 차이점이 무엇인가요?
* BST 의 경우에는 노드의 값에 '순서' 나 '크고 작음' 이 존재합니다. 노드의 왼쪽 서브트리의 경우에는 그 노드의 값보다 작은 값을 가진 노드로 이루어져 있고 반대로 오른쪽 서브 트리는 그 노드의 값보다 큰 값을 가진 노드로 이루어져 있습니다.

## Q 5 . BST 의 시간 복잡도는 어떻게 되나요? 이상적인 경우와 Worst Case 에 대해서도 얘기해주세요.
* Worst Case 인 경우는 Skewed Tree 가 될 경우 입니다. 이때에는 정렬된 배열과 시간복잡도가 같아져 O(N) 의 시간복잡도를 가지게 됩니다.
* 이상적인 경우는 밸런스가 잘 맞는 경우로 한 쪽으로 치우쳐지지 않았을 때입니다. 이때 탐색, 삽입, 삭제의 경우 모두 O(logN) 의 시간복잡도를 가지게 됩니다.

# 그래프

## Q 1 . 그래프란 무엇인가요 ?
* 노드와 노드를 연결하는 간선을 하나로 모아 놓은 자료 구조입니다. 연결되어 있는 객체 간의 관계를 표현할 수 있는 자료구조로 비선형 자료구조입니다. 
## Q 2 . 트리와 그래프의 차이는 무엇인가요 ?
* 트리는 그래프의 한 종류로 DAG, 즉 방향성이 있는 비순환 그래프의 한 종류입니다. 그래프와는 다르게 싸이클이 불가능하고, 자체 간선 또한 불가능합니다.또한 트리는 방향 그래프 만이 존재가 가능합니다.
## Q 3 . DFS/BFS 의 차이는 무엇인가요 ?
* DFS 는 깊이 우선 탐색입니다. 루트 노드나 다른 임의의 노드에서 시작해서 다음 분기로 넘어가기전에 해당 분기를 완벽하게 탐색하는 방법입니다. 주로 스택이나 재귀를 통해 구현하고 모든 노드를 방문하고자 하는 경우에 이 방법을 선택합니다. 한 방향으로 진행하다가 더 이상 갈 수 없게 된다면 다시 가장 가까운 갈림길로 돌아와서 다른 방향으로 탐색을 진행합니다. 
* BFS 는 너비 우선 탐색입니다. 시작 정점으로부터 가까운 정점을 먼저 방문하고 멀리 떨어져 있는 정점을 나중에 방문하는 순회 방법입니다. 깊게 탐색하기 전에 넓게 탐색하고, 두 노드 사이의 최단 경로나 임의의 경로를 찾고 싶을 때 사용합니다. 일반적으로 큐를 통해 구현합니다.

## Q 4 . 그래프를 인접 행렬로 구현했을 때와 인접리스트로 구현했을 때의 차이점을 얘기해주세요.
* 인접 행렬로 구현할 경우 이차원 배열을 통해서 구현합니다. 인접 행렬로 구현시에 대각 성분을 기준으로 대칭인 성질을 가지게 됩니다. 인접 행렬은 구현이 쉽습니다. 노드의 연결 여부 파악시에 인덱스를 통해 1인지 0인지만 판단하면 되기 때문에 O(1) 이라는 시간 복잡도에 확인 할 수 있습니다. 하지만 전체 노드의 개수를 V 개, 간선의 개수를 E 라고 할 때 노드 i 에 연결된 모든 노드에 방문하고 싶은 경우 전부 확인해봐야 하기 때문에 총 O(V) 의 시간이 걸립니다. 만약 노드의 수가 간선의 개수보다 훨씬 적다면 인접 행렬 방식은 적절하지 않습니다.
* 인접 리스트로 구현하는 경우에는 각각의 노드에 연결된 노드들을 원소로 갖는 리스트로 구현합니다. 인접 행렬과는 달리 실제로 연결된 노드들에 대한 정보만 저장하기 때문에 간선에 개수에 비례하는 메모리만 차지하게 됩니다. 결국 인접리스트의 경우엔 각 노드마다 연결되 있는 노드만 확인이 가능하기 때문에 전체 간선의 개수만큼 확인이 가능해 O(E) 의 시간 복잡도를 가지게 됩니다. 하지만 노드간의 연결 관계를 확인하기 위해서는 리스트를 돌며 확인해야 하므로 시간 복잡도가 O(V) 가 됩니다. 반대로 인접 리스트는 sparse 한 경우, 즉 노드의 수보다 간선의 개수가 적은 경우 유리합니다.

## Q 5 . MST 란 무엇인가요?
* Spanning Tree, 즉 그래프의 모든 정점을 포함하는 트리중에서 사용된 간선들의 가중치 합이 최소인 트리를 얘기합니다. 가중치의 합이 최소이고, 사이클이 존재하지 않습니다. 주로 통신망이나 도로망 등에서 길이나 구축 비용, 전송 시간등을 최소로 구축하는 경우에 사용합니다.
## Q 6 . MST 를 구현하는 방식 2가지를 얘기해주세요.
* MST 는 Kruskal, Prim 알고리즘으로 구현이 가능합니다. 먼저 Kruskal 알고리즘의 경우 모든 간서의 기중치를 오름 차순으로 정렬합니다. 이 때 작은 가중치의 간선부터 하나씩 선택하며 MST 를 구성합니다. 만약 사이클이 형성된다면 간선을 선택하지 않는데, Union-find 알고리즘을 통해 사이클 형성을 판단합니다. Union-find 는 각 노드의 부모 노드를 저장하는 집합을 통해 루트 노드를 찾는 방식입니다. 루트 노드를 찾는 Find 동작을 통해 다른 루트 노드일때만 간선을 선택해 사이클 형성을 피할 수 있습니다.
* Prim 알고리즘은 
## Q 7 . 다익스트라 알고리즘이란 무엇인가요?
* 다익스트라 알고리즘은 그래프의 한 정점에서 다른 정점으로 가는 최단 경로를 구하는 알고리즘입니다. dynamic programing 을 활용해 구현하고 Min heap 을 통해 최적화가 가능합니다. 만약 Min Heap 에 기록된 거리가 거리 배열에 저장된 해당 정점의 거리보다 길면 건너뛰는 방식으로 구현합니다.
## Q 8 . 최단 거리를 출력하려면 어떻게 해야 할까요?

## Q 9 . 최단 거리를 만드는 모든 경로를 출력하려면 어떻게 해야 할 까요?




